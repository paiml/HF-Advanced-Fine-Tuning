{"text": "<code>struct PathCompleter {}</code>\n<doc>/// Complete a value as a [`std::path::Path`]\n///\n/// # Example\n///\n/// ```rust\n/// use clap::Parser;\n/// use clap_complete::engine::{ArgValueCompleter, PathCompleter};\n///\n/// #[derive(Debug, Parser)]\n/// struct Cli {\n///     #[arg(long, add = ArgValueCompleter::new(PathCompleter::file()))]\n///     custom: Option<String>,\n/// }\n/// ```</doc>"}
{"text": "<code>enum ThemePreference {}</code>\n<doc>/// What theme should `bat` use?\n///\n/// The easiest way to construct this is from a string:\n/// ```\n/// # use bat::theme::{ThemePreference, DetectColorScheme};\n/// let preference = ThemePreference::new(\"auto:system\");\n/// assert_eq!(ThemePreference::Auto(DetectColorScheme::System), preference);\n/// ```</doc>"}
{"text": "<code>enum ThemeName {}</code>\n<doc>/// The name of a theme or the default theme.\n///\n/// ```\n/// # use bat::theme::ThemeName;\n/// assert_eq!(ThemeName::Default, ThemeName::new(\"default\"));\n/// assert_eq!(ThemeName::Named(\"example\".to_string()), ThemeName::new(\"example\"));\n/// ```</doc>"}
{"text": "<code>fn from_shell_path<P>(path: P) -> Option < Shell > {}</code>\n<doc>/// Parse a shell from a path to the executable for the shell\n///\n/// # Examples\n///\n/// ```\n/// use clap_complete::shells::Shell;\n///\n/// assert_eq!(Shell::from_shell_path(\"/bin/bash\"), Some(Shell::Bash));\n/// assert_eq!(Shell::from_shell_path(\"/usr/bin/zsh\"), Some(Shell::Zsh));\n/// assert_eq!(Shell::from_shell_path(\"/opt/my_custom_shell\"), None);\n/// ```</doc>"}
{"text": "<code>fn generate<G, S>(generator: G, cmd: & mut Command, bin_name: S, buf: & mut dyn Write) {}</code>\n<doc>/// Generate a completions file for a specified shell at runtime.\n///\n/// Until `cargo install` can install extra files like a completion script, this may be\n/// used e.g. in a command that outputs the contents of the completion script, to be\n/// redirected into a file by the user.\n///\n/// # Examples\n///\n/// Assuming a separate `cli.rs` like the [`generate_to` example](generate_to()),\n/// we can let users generate a completion script using a command:\n///\n/// ```ignore\n/// // src/main.rs\n///\n/// mod cli;\n/// use std::io;\n/// use clap_complete::{generate, shells::Bash};\n///\n/// fn main() {\n///     let matches = cli::build_cli().get_matches();\n///\n///     if matches.is_present(\"generate-bash-completions\") {\n///         generate(Bash, &mut cli::build_cli(), \"myapp\", &mut io::stdout());\n///     }\n///\n///     // normal logic continues...\n/// }\n///\n/// ```\n///\n/// Usage:\n///\n/// ```console\n/// $ myapp generate-bash-completions > /usr/share/bash-completion/completions/myapp.bash\n/// ```</doc>"}
{"text": "<code>fn new(id: impl Into < Id >) -> Self {}</code>\n<doc>/// Create a `ArgGroup` using a unique name.\n///\n/// The name will be used to get values from the group or refer to the group inside of conflict\n/// and requirement rules.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, ArgGroup};\n/// ArgGroup::new(\"config\")\n/// # ;\n/// ```</doc>"}
{"text": "<code>fn new(name: impl Into < Str >) -> Self {}</code>\n<doc>/// Creates a new instance of an `Command`.\n///\n/// It is common, but not required, to use binary name as the `name`. This\n/// name will only be displayed to the user when they request to print\n/// version or help and usage information.\n///\n/// See also [`command!`](crate::command!) and [`crate_name!`](crate::crate_name!).\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::Command;\n/// Command::new(\"My Program\")\n/// # ;\n/// ```</doc>"}
{"text": "<code>fn no_binary_name(self, yes: bool) -> Self {}</code>\n<doc>/// Specifies that the parser should not assume the first argument passed is the binary name.\n///\n/// This is normally the case when using a \"daemon\" style mode.  For shells / REPLs, see\n/// [`Command::multicall`][Command::multicall].\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, arg};\n/// let m = Command::new(\"myprog\")\n///     .no_binary_name(true)\n///     .arg(arg!(<cmd> ... \"commands to run\"))\n///     .get_matches_from(vec![\"command\", \"set\"]);\n///\n/// let cmds: Vec<_> = m.get_many::<String>(\"cmd\").unwrap().collect();\n/// assert_eq!(cmds, [\"command\", \"set\"]);\n/// ```\n/// [`try_get_matches_from_mut`]: crate::Command::try_get_matches_from_mut()</doc>"}
{"text": "<code>fn name(self, name: impl Into < Str >) -> Self {}</code>\n<doc>/// (Re)Sets the program's name.\n///\n/// See [`Command::new`] for more details.\n///\n/// # Examples\n///\n/// ```ignore\n/// let cmd = clap::command!()\n///     .name(\"foo\");\n///\n/// // continued logic goes here, such as `cmd.get_matches()` etc.\n/// ```</doc>"}
{"text": "<code>fn short_flag(self, short: impl IntoResettable < char >) -> Self {}</code>\n<doc>/// Sets the short version of the subcommand flag without the preceding `-`.\n///\n/// Allows the subcommand to be used as if it were an [`Arg::short`].\n///\n/// # Examples\n///\n/// ```\n/// # use clap_builder as clap;\n/// # use clap::{Command, Arg, ArgAction};\n/// let matches = Command::new(\"pacman\")\n///     .subcommand(\n///         Command::new(\"sync\").short_flag('S').arg(\n///             Arg::new(\"search\")\n///                 .short('s')\n///                 .long(\"search\")\n///                 .action(ArgAction::SetTrue)\n///                 .help(\"search remote repositories for matching strings\"),\n///         ),\n///     )\n///     .get_matches_from(vec![\"pacman\", \"-Ss\"]);\n///\n/// assert_eq!(matches.subcommand_name().unwrap(), \"sync\");\n/// let sync_matches = matches.subcommand_matches(\"sync\").unwrap();\n/// assert!(sync_matches.get_flag(\"search\"));\n/// ```\n/// [`Arg::short`]: Arg::short()</doc>"}
