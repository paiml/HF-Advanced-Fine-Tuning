{"id": "67e1df3b-027b-5a27-826c-028c5be8400f", "input": "struct PathCompleter {}", "output": "/// Complete a value as a [`std::path::Path`]\n///\n/// # Example\n///\n/// ```rust\n/// use clap::Parser;\n/// use clap_complete::engine::{ArgValueCompleter, PathCompleter};\n///\n/// #[derive(Debug, Parser)]\n/// struct Cli {\n///     #[arg(long, add = ArgValueCompleter::new(PathCompleter::file()))]\n///     custom: Option<String>,\n/// }\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/engine/custom.rs", "source_line": 214, "tokens_input": 6, "tokens_output": 85, "quality_score": 1.0}
{"id": "30c58ecd-1633-505d-91e3-abbc795c82ae", "input": "enum ThemePreference {}", "output": "/// What theme should `bat` use?\n///\n/// The easiest way to construct this is from a string:\n/// ```\n/// # use bat::theme::{ThemePreference, DetectColorScheme};\n/// let preference = ThemePreference::new(\"auto:system\");\n/// assert_eq!(ThemePreference::Auto(DetectColorScheme::System), preference);\n/// ```", "category": "example", "source_repo": "sharkdp/bat", "source_commit": "cd06fe4", "source_file": "src/theme.rs", "source_line": 67, "tokens_input": 6, "tokens_output": 76, "quality_score": 1.0}
{"id": "31075dd7-4b17-5d8a-ac0b-4fd462448abf", "input": "enum ThemeName {}", "output": "/// The name of a theme or the default theme.\n///\n/// ```\n/// # use bat::theme::ThemeName;\n/// assert_eq!(ThemeName::Default, ThemeName::new(\"default\"));\n/// assert_eq!(ThemeName::Named(\"example\".to_string()), ThemeName::new(\"example\"));\n/// ```", "category": "example", "source_repo": "sharkdp/bat", "source_commit": "cd06fe4", "source_file": "src/theme.rs", "source_line": 131, "tokens_input": 5, "tokens_output": 62, "quality_score": 1.0}
{"id": "3a570054-6021-5f97-9c6d-2a058b5f5d85", "input": "fn from_shell_path<P>(path: P) -> Option < Shell > {}", "output": "/// Parse a shell from a path to the executable for the shell\n///\n/// # Examples\n///\n/// ```\n/// use clap_complete::shells::Shell;\n///\n/// assert_eq!(Shell::from_shell_path(\"/bin/bash\"), Some(Shell::Bash));\n/// assert_eq!(Shell::from_shell_path(\"/usr/bin/zsh\"), Some(Shell::Zsh));\n/// assert_eq!(Shell::from_shell_path(\"/opt/my_custom_shell\"), None);\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/aot/shells/shell.rs", "source_line": 112, "tokens_input": 14, "tokens_output": 90, "quality_score": 1.0}
{"id": "2eebdf51-0d4e-5a3e-98af-43f2b10a730e", "input": "fn generate<G, S>(generator: G, cmd: & mut Command, bin_name: S, buf: & mut dyn Write) {}", "output": "/// Generate a completions file for a specified shell at runtime.\n///\n/// Until `cargo install` can install extra files like a completion script, this may be\n/// used e.g. in a command that outputs the contents of the completion script, to be\n/// redirected into a file by the user.\n///\n/// # Examples\n///\n/// Assuming a separate `cli.rs` like the [`generate_to` example](generate_to()),\n/// we can let users generate a completion script using a command:\n///\n/// ```ignore\n/// // src/main.rs\n///\n/// mod cli;\n/// use std::io;\n/// use clap_complete::{generate, shells::Bash};\n///\n/// fn main() {\n///     let matches = cli::build_cli().get_matches();\n///\n///     if matches.is_present(\"generate-bash-completions\") {\n///         generate(Bash, &mut cli::build_cli(), \"myapp\", &mut io::stdout());\n///     }\n///\n///     // normal logic continues...\n/// }\n///\n/// ```\n///\n/// Usage:\n///\n/// ```console\n/// $ myapp generate-bash-completions > /usr/share/bash-completion/completions/myapp.bash\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/aot/generator/mod.rs", "source_line": 293, "tokens_input": 23, "tokens_output": 249, "quality_score": 1.0}
{"id": "882ae145-b890-56db-a7a7-40c68daec926", "input": "fn new(id: impl Into < Id >) -> Self {}", "output": "/// Create a `ArgGroup` using a unique name.\n///\n/// The name will be used to get values from the group or refer to the group inside of conflict\n/// and requirement rules.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, ArgGroup};\n/// ArgGroup::new(\"config\")\n/// # ;\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/arg_group.rs", "source_line": 92, "tokens_input": 10, "tokens_output": 80, "quality_score": 1.0}
{"id": "cb6a555e-ee7f-5e56-9b71-62e45dfa26ff", "input": "fn new(name: impl Into < Str >) -> Self {}", "output": "/// Creates a new instance of an `Command`.\n///\n/// It is common, but not required, to use binary name as the `name`. This\n/// name will only be displayed to the user when they request to print\n/// version or help and usage information.\n///\n/// See also [`command!`](crate::command!) and [`crate_name!`](crate::crate_name!).\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::Command;\n/// Command::new(\"My Program\")\n/// # ;\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/command.rs", "source_line": 133, "tokens_input": 11, "tokens_output": 116, "quality_score": 1.0}
{"id": "a84694d7-11fa-571f-b25b-9863d1eafcb6", "input": "fn no_binary_name(self, yes: bool) -> Self {}", "output": "/// Specifies that the parser should not assume the first argument passed is the binary name.\n///\n/// This is normally the case when using a \"daemon\" style mode.  For shells / REPLs, see\n/// [`Command::multicall`][Command::multicall].\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, arg};\n/// let m = Command::new(\"myprog\")\n///     .no_binary_name(true)\n///     .arg(arg!(<cmd> ... \"commands to run\"))\n///     .get_matches_from(vec![\"command\", \"set\"]);\n///\n/// let cmds: Vec<_> = m.get_many::<String>(\"cmd\").unwrap().collect();\n/// assert_eq!(cmds, [\"command\", \"set\"]);\n/// ```\n/// [`try_get_matches_from_mut`]: crate::Command::try_get_matches_from_mut()", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/command.rs", "source_line": 1186, "tokens_input": 12, "tokens_output": 175, "quality_score": 1.0}
{"id": "80bc489f-921f-5512-921e-07c422e85843", "input": "fn name(self, name: impl Into < Str >) -> Self {}", "output": "/// (Re)Sets the program's name.\n///\n/// See [`Command::new`] for more details.\n///\n/// # Examples\n///\n/// ```ignore\n/// let cmd = clap::command!()\n///     .name(\"foo\");\n///\n/// // continued logic goes here, such as `cmd.get_matches()` etc.\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/command.rs", "source_line": 1863, "tokens_input": 13, "tokens_output": 62, "quality_score": 1.0}
{"id": "cdfcbd23-d313-5b21-b75d-74e8c4f2bad1", "input": "fn short_flag(self, short: impl IntoResettable < char >) -> Self {}", "output": "/// Sets the short version of the subcommand flag without the preceding `-`.\n///\n/// Allows the subcommand to be used as if it were an [`Arg::short`].\n///\n/// # Examples\n///\n/// ```\n/// # use clap_builder as clap;\n/// # use clap::{Command, Arg, ArgAction};\n/// let matches = Command::new(\"pacman\")\n///     .subcommand(\n///         Command::new(\"sync\").short_flag('S').arg(\n///             Arg::new(\"search\")\n///                 .short('s')\n///                 .long(\"search\")\n///                 .action(ArgAction::SetTrue)\n///                 .help(\"search remote repositories for matching strings\"),\n///         ),\n///     )\n///     .get_matches_from(vec![\"pacman\", \"-Ss\"]);\n///\n/// assert_eq!(matches.subcommand_name().unwrap(), \"sync\");\n/// let sync_matches = matches.subcommand_matches(\"sync\").unwrap();\n/// assert!(sync_matches.get_flag(\"search\"));\n/// ```\n/// [`Arg::short`]: Arg::short()", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/command.rs", "source_line": 2605, "tokens_input": 17, "tokens_output": 224, "quality_score": 1.0}
{"id": "5ec52fa4-cf12-577b-b67e-b808e00abf9c", "input": "fn group(self, group_id: impl IntoResettable < Id >) -> Self {}", "output": "/// The name of the [`ArgGroup`] the argument belongs to.\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, Arg, ArgAction};\n/// Arg::new(\"debug\")\n///     .long(\"debug\")\n///     .action(ArgAction::SetTrue)\n///     .group(\"mode\")\n/// # ;\n/// ```\n///\n/// Multiple arguments can be a member of a single group and then the group checked as if it\n/// was one of said arguments.\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::{Command, Arg, ArgAction};\n/// let m = Command::new(\"prog\")\n///     .arg(Arg::new(\"debug\")\n///         .long(\"debug\")\n///         .action(ArgAction::SetTrue)\n///         .group(\"mode\"))\n///     .arg(Arg::new(\"verbose\")\n///         .long(\"verbose\")\n///         .action(ArgAction::SetTrue)\n///         .group(\"mode\"))\n///     .get_matches_from(vec![\n///         \"prog\", \"--debug\"\n///     ]);\n/// assert!(m.contains_id(\"mode\"));\n/// ```\n///\n/// [`ArgGroup`]: crate::ArgGroup", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/arg.rs", "source_line": 2883, "tokens_input": 16, "tokens_output": 238, "quality_score": 1.0}
{"id": "695b5493-4a94-5d1f-93f1-907bb0a47c10", "input": "fn new(range: impl Into < Self >) -> Self {}", "output": "/// Create a range\n///\n/// # Panics\n///\n/// If the end is less than the start (debug builds)\n///\n/// # Examples\n///\n/// ```rust\n/// # use clap_builder as clap;\n/// # use clap::builder::ValueRange;\n/// let range = ValueRange::new(5);\n/// let range = ValueRange::new(5..10);\n/// let range = ValueRange::new(5..=10);\n/// let range = ValueRange::new(5..);\n/// let range = ValueRange::new(..10);\n/// let range = ValueRange::new(..=10);\n/// ```\n///\n/// While this will panic:\n/// ```should_panic\n/// # use clap_builder as clap;\n/// # use clap::builder::ValueRange;\n/// let range = ValueRange::new(10..5);  // Panics!\n/// ```", "category": "example", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/range.rs", "source_line": 57, "tokens_input": 11, "tokens_output": 155, "quality_score": 1.0}
{"id": "99ba9911-3f14-5ad1-8f55-ab7626364532", "input": "const fn is_none(&self) -> bool {}", "output": "/// Returns `true` if `None`\n///\n/// # Examples\n///\n/// ```\n/// use eza::fs::recursive_size::RecursiveSize;\n///\n/// let x = RecursiveSize::None;\n/// assert_eq!(x.is_none(), true);\n///\n/// let x = RecursiveSize::Unknown;\n/// assert_eq!(x.is_none(), false);\n///\n/// let x = RecursiveSize::Some(0, 0);\n/// assert_eq!(x.is_none(), false);\n/// ```", "category": "example", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/fs/recursive_size.rs", "source_line": 41, "tokens_input": 9, "tokens_output": 86, "quality_score": 1.0}
{"id": "8c89f0ac-3fea-57a7-9197-6d26f4f208ba", "input": "fn get_statistics<A>(&mut self, paths: & [A], ignored: & [& str], config: & Config) {}", "output": "/// Populates the `Languages` struct with statistics about languages\n/// provided by [`Language`].\n///\n/// Takes a `&[&str]` of paths to recursively traverse, paths can be\n/// relative, absolute or glob paths. A second `&[&str]` of paths to ignore,\n/// these strings use the `.gitignore` syntax, such as `target`\n/// or `**/*.bk`.\n///\n/// ```no_run\n/// use tokei::{Config, Languages};\n///\n/// let mut languages = Languages::new();\n/// languages.get_statistics(&[\".\"], &[\".git\", \"target\"], &Config::default());\n/// ```\n///\n/// [`Language`]: struct.Language.html", "category": "example", "source_repo": "XAMPPRocky/tokei", "source_commit": "6c71dd7", "source_file": "src/language/languages.rs", "source_line": 79, "tokens_input": 22, "tokens_output": 140, "quality_score": 1.0}
{"id": "0ef9cce3-bc69-54f8-94f8-0c4caac1565d", "input": "fn all_subcommands(cmd: & Command) -> Vec < (String , String) > {}", "output": "/// Gets all subcommands including child subcommands in the form of `(\"name\", \"bin_name\")`.\n///\n/// Subcommand `rustup toolchain install` would be converted to\n/// `(\"install\", \"rustup toolchain install\")`.", "category": "function", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/aot/generator/utils.rs", "source_line": 9, "tokens_input": 17, "tokens_output": 52, "quality_score": 0.9000001}
{"id": "b9d50329-d433-570f-b19c-7e7ed751b9ec", "input": "fn str_to_bool(val: impl AsRef < str >) -> Option < bool > {}", "output": "/// Converts a string literal representation of truth to true or false.\n///\n/// `false` values are `n`, `no`, `f`, `false`, `off`, and `0` (case insensitive).\n///\n/// Any other value will be considered as `true`.", "category": "function", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/util/str_to_bool.rs", "source_line": 12, "tokens_input": 16, "tokens_output": 53, "quality_score": 0.9000001}
{"id": "b7c1ecc7-dd13-5cc2-bdd4-7f68ec44b364", "input": "fn build(&mut self) {}", "output": "/// Prepare for introspecting on all included [`Command`]s\n///\n/// Call this on the top-level [`Command`] when done building and before reading state for\n/// cases like completions, custom help output, etc.", "category": "function", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/builder/command.rs", "source_line": 4379, "tokens_input": 6, "tokens_output": 52, "quality_score": 0.9000001}
{"id": "f2e885f6-d8d7-5f93-b931-108a0fcce8e6", "input": "fn did_you_mean<T, I>(v: & str, possible_values: I) -> Vec < String > {}", "output": "/// Find strings from an iterable of `possible_values` similar to a given value `v`\n/// Returns a Vec of all possible values that exceed a similarity threshold\n/// sorted by ascending similarity, most similar comes last", "category": "function", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/parser/features/suggestions.rs", "source_line": 8, "tokens_input": 18, "tokens_output": 55, "quality_score": 0.9000001}
{"id": "1fb8e1b4-a56b-5e79-9555-2ce7df4f872f", "input": "struct KindFormatter {}", "output": "/// Report [`ErrorKind`]\n///\n/// No context is included.\n///\n/// <div class=\"warning\">\n///\n/// **NOTE:** Consider removing the `error-context` default feature if using this to remove all\n/// overhead for [`RichFormatter`].\n///\n/// </div>", "category": "function", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/error/format.rs", "source_line": 36, "tokens_input": 6, "tokens_output": 60, "quality_score": 0.9000001}
{"id": "963a12d1-0ff3-564d-8fee-5e014e81e1e0", "input": "fn set_windows_exe_options() {}", "output": "/// Embed a Windows manifest and set some linker options.\n///\n/// The main reason for this is to enable long path support on Windows. This\n/// still, I believe, requires enabling long path support in the registry. But\n/// if that's enabled, then this will let ripgrep use C:\\... style paths that\n/// are longer than 260 characters.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "build.rs", "source_line": 12, "tokens_input": 8, "tokens_output": 83, "quality_score": 0.9000001}
{"id": "7f47f8c7-f0e1-5d07-a402-0720e9d1b252", "input": "fn setup(test_name: & str) -> (Dir , TestCommand) {}", "output": "/// Setup an empty work directory and return a command pointing to the ripgrep\n/// executable whose CWD is set to the work directory.\n///\n/// The name given will be used to create the directory. Generally, it should\n/// correspond to the test name.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "tests/util.rs", "source_line": 22, "tokens_input": 13, "tokens_output": 62, "quality_score": 0.9000001}
{"id": "e4638518-b85f-5c72-bc1f-f5f518412730", "input": "fn strip_jemalloc_nonsense(data: & [u8]) -> Vec < u8 > {}", "output": "/// Strips absolutely fucked `<jemalloc>:` lines from the output.\n///\n/// In theory this only happens under qemu, which is where our tests run under\n/// `cross`. But is messes with our tests, because... they don't expect the\n/// allocator to fucking write to stderr. I mean, what the fuck? Who prints a\n/// warning message with absolutely no instruction for what to do with it or\n/// how to disable it. Absolutely fucking bonkers.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "tests/util.rs", "source_line": 509, "tokens_input": 15, "tokens_output": 108, "quality_score": 0.9000001}
{"id": "4c95e31a-fdfb-5aea-88a8-4e3b2fe10c87", "input": "fn default_color_specs() -> Vec < UserColorSpec > {}", "output": "/// Returns a default set of color specifications.\n///\n/// This may change over time, but the color choices are meant to be fairly\n/// conservative that work across terminal themes.\n///\n/// Additional color specifications can be added to the list returned. More\n/// recently added specifications override previously added specifications.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/color.rs", "source_line": 10, "tokens_input": 13, "tokens_output": 85, "quality_score": 0.9000001}
{"id": "15d4dce3-887e-54ae-b4d4-7f9fff07e887", "input": "struct ColorSpecs {}", "output": "/// A merged set of color specifications.\n///\n/// This set of color specifications represents the various color types that\n/// are supported by the printers in this crate. A set of color specifications\n/// can be created from a sequence of\n/// [`UserColorSpec`]s.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/color.rs", "source_line": 88, "tokens_input": 5, "tokens_output": 66, "quality_score": 0.9000001}
{"id": "8d936d8a-2fca-57e4-839c-43402a3e0624", "input": "fn to_color_spec(&self) -> ColorSpec {}", "output": "/// Convert this user provided color specification to a specification that\n/// can be used with `termcolor`. This drops the type of this specification\n/// (where the type indicates where the color is applied in the standard\n/// printer, e.g., to the file path or the line numbers, etc.).", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/color.rs", "source_line": 162, "tokens_input": 10, "tokens_output": 72, "quality_score": 0.9000001}
{"id": "9de1f992-d284-5dbc-bb83-9686d0aba596", "input": "struct Config {}", "output": "/// The configuration for the standard printer.\n///\n/// This is manipulated by the StandardBuilder and then referenced by the\n/// actual implementation. Once a printer is build, the configuration is frozen\n/// and cannot changed.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/standard.rs", "source_line": 36, "tokens_input": 4, "tokens_output": 58, "quality_score": 0.9000001}
{"id": "f394aba6-c057-544f-87ca-ad33ce347350", "input": "fn new_no_color(wtr: W) -> Standard < NoColor < W > > {}", "output": "/// Return a standard printer with a default configuration that writes\n/// matches to the given writer.\n///\n/// The writer can be any implementation of `io::Write`. With this\n/// constructor, the printer will never emit colors.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/standard.rs", "source_line": 505, "tokens_input": 14, "tokens_output": 57, "quality_score": 0.9000001}
{"id": "dde46cf0-4b90-50a5-ab95-b05e48ee233c", "input": "fn sink<'s, M>(&mut self, matcher: M) -> StandardSink < 'static , 's , M , W > {}", "output": "/// Return an implementation of `Sink` for the standard printer.\n///\n/// This does not associate the printer with a file path, which means this\n/// implementation will never print a file path along with the matches.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/standard.rs", "source_line": 515, "tokens_input": 21, "tokens_output": 54, "quality_score": 0.9000001}
{"id": "16f60d0c-244d-58c2-be9e-05614096ea0e", "input": "struct StandardImpl {}", "output": "/// The actual implementation of the standard printer. This couples together\n/// the searcher, the sink implementation and information about the match.\n///\n/// A StandardImpl is initialized every time a match or a contextual line is\n/// reported.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/standard.rs", "source_line": 876, "tokens_input": 6, "tokens_output": 62, "quality_score": 0.9000001}
{"id": "3c02321d-1d31-55d1-a472-85cce6eb8b8e", "input": "struct Config {}", "output": "/// The configuration for the summary printer.\n///\n/// This is manipulated by the SummaryBuilder and then referenced by the actual\n/// implementation. Once a printer is build, the configuration is frozen and\n/// cannot changed.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/summary.rs", "source_line": 29, "tokens_input": 4, "tokens_output": 57, "quality_score": 0.9000001}
{"id": "2f173122-971a-541d-b0b9-e7f5cd404579", "input": "fn requires_path(&self) -> bool {}", "output": "/// Returns true if and only if this output mode requires a file path.\n///\n/// When an output mode requires a file path, then the summary printer\n/// will report an error at the start of every search that lacks a file\n/// path.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/summary.rs", "source_line": 103, "tokens_input": 9, "tokens_output": 57, "quality_score": 0.9000001}
{"id": "e41f7ed0-f035-56ca-ab5b-8a4199ee50e9", "input": "fn sink<'s, M>(&mut self, matcher: M) -> SummarySink < 'static , 's , M , W > {}", "output": "/// Return an implementation of `Sink` for the summary printer.\n///\n/// This does not associate the printer with a file path, which means this\n/// implementation will never print a file path. If the output mode of\n/// this summary printer does not make sense without a file path (such as\n/// `PathWithMatch` or `PathWithoutMatch`), then any searches executed\n/// using this sink will immediately quit with an error.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/summary.rs", "source_line": 390, "tokens_input": 20, "tokens_output": 104, "quality_score": 0.9000001}
{"id": "43ce73de-f7f8-57aa-a641-5b22264b8464", "input": "struct HyperlinkEnvironment {}", "output": "/// A static environment for hyperlink interpolation.\n///\n/// This environment permits setting the values of variables used in hyperlink\n/// interpolation that are not expected to change for the lifetime of a program.\n/// That is, these values are invariant.\n///\n/// Currently, this includes the hostname and a WSL distro prefix.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/hyperlink/mod.rs", "source_line": 251, "tokens_input": 8, "tokens_output": 83, "quality_score": 0.9000001}
{"id": "6aeb3fec-6a8d-5f67-bf6f-1be3ff156ee0", "input": "struct InterpolatorStatus {}", "output": "/// A status indicating whether a hyperlink was written or not.\n///\n/// This is created by `Interpolator::begin` and used by `Interpolator::finish`\n/// to determine whether a hyperlink was actually opened or not. If it wasn't\n/// opened, then finishing interpolation is a no-op.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/hyperlink/mod.rs", "source_line": 693, "tokens_input": 7, "tokens_output": 70, "quality_score": 0.9000001}
{"id": "7e0f2608-008d-5b0f-9a62-516f94f9f7a9", "input": "struct NiceDuration {}", "output": "/// A type that provides \"nicer\" Display and Serialize impls for\n/// std::time::Duration. The serialization format should actually be compatible\n/// with the Deserialize impl for std::time::Duration, since this type only\n/// adds new fields.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/util.rs", "source_line": 372, "tokens_input": 6, "tokens_output": 61, "quality_score": 0.9000001}
{"id": "ded3cf3a-b2df-5e92-ada1-cbaffdb284e9", "input": "fn fractional_seconds(&self) -> f64 {}", "output": "/// Returns the number of seconds in this duration in fraction form.\n/// The number to the left of the decimal point is the number of seconds,\n/// and the number to the right is the number of milliseconds.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/util.rs", "source_line": 384, "tokens_input": 10, "tokens_output": 52, "quality_score": 0.9000001}
{"id": "d8563d29-2aa7-5317-845e-0e3968df6a38", "input": "struct DecimalFormatter {}", "output": "/// A simple formatter for converting `u64` values to ASCII byte strings.\n///\n/// This avoids going through the formatting machinery which seems to\n/// substantially slow things down.\n///\n/// The `itoa` crate does the same thing as this formatter, but is a bit\n/// faster. We roll our own which is a bit slower, but gets us enough of a win\n/// to be satisfied with and with pure safe code.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/util.rs", "source_line": 415, "tokens_input": 7, "tokens_output": 98, "quality_score": 0.9000001}
{"id": "bf8d0469-107a-571c-b70a-96a1a8e0ef2f", "input": "fn trim_line_terminator<'b>(searcher: & Searcher, buf: & 'b [u8], line: & mut Match) -> & 'b [u8] {}", "output": "/// Given a buf and some bounds, if there is a line terminator at the end of\n/// the given bounds in buf, then the bounds are trimmed to remove the line\n/// terminator, returning the slice of the removed line terminator (if any).", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/util.rs", "source_line": 535, "tokens_input": 25, "tokens_output": 58, "quality_score": 0.9000001}
{"id": "608faffe-d8ad-5550-8256-11a3f5700244", "input": "struct Config {}", "output": "/// The configuration for the JSON printer.\n///\n/// This is manipulated by the JSONBuilder and then referenced by the actual\n/// implementation. Once a printer is build, the configuration is frozen and\n/// cannot changed.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/json.rs", "source_line": 25, "tokens_input": 4, "tokens_output": 56, "quality_score": 0.9000001}
{"id": "88d87ff6-dffc-57de-b02e-ba08f716285c", "input": "enum SubMatches {}", "output": "/// SubMatches represents a set of matches in a contiguous range of bytes.\n///\n/// A simpler representation for this would just simply be `Vec<SubMatch>`,\n/// but the common case is exactly one match per range of bytes, which we\n/// specialize here using a fixed size array without any allocation.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/printer/src/json.rs", "source_line": 847, "tokens_input": 5, "tokens_output": 75, "quality_score": 0.9000001}
{"id": "930fca18-77aa-5c58-8dfc-348f20265e72", "input": "fn has_uppercase_literal(pattern: & str) -> bool {}", "output": "/// Determine whether the pattern contains an uppercase character which should\n/// negate the effect of the smart-case option.\n///\n/// Ideally we would be able to check the AST in order to correctly handle\n/// things like '\\p{Ll}' and '\\p{Lu}' (which should be treated as explicitly\n/// cased), but PCRE doesn't expose enough details for that kind of analysis.\n/// For now, our 'good enough' solution is to simply perform a semi-na\u00efve\n/// scan of the input pattern and ignore all characters following a '\\'. The\n/// This at least lets us support the most common cases, like 'foo\\w' and\n/// 'foo\\S', in an intuitive manner.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/pcre2/src/matcher.rs", "source_line": 422, "tokens_input": 13, "tokens_output": 156, "quality_score": 0.9000001}
{"id": "18abdbc7-9924-59bf-b39a-4e53024150aa", "input": "struct Error {}", "output": "/// An error that can occur in this crate.\n///\n/// Generally, this error corresponds to problems building a regular\n/// expression, whether it's in parsing, compilation or a problem with\n/// guaranteeing a configured optimization.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/pcre2/src/error.rs", "source_line": 7, "tokens_input": 4, "tokens_output": 58, "quality_score": 0.9000001}
{"id": "41bbe76d-1c70-536f-8718-52913e111cde", "input": "fn parse_low() -> ParseResult < LowArgs > {}", "output": "/// Parse CLI arguments only into their low level representation.\n///\n/// This takes configuration into account. That is, it will try to read\n/// `RIPGREP_CONFIG_PATH` and prepend any arguments found there to the\n/// arguments passed to this process.\n///\n/// This will also set one-time global state flags, such as the log level and\n/// whether messages should be printed.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/parse.rs", "source_line": 64, "tokens_input": 11, "tokens_output": 93, "quality_score": 0.9000001}
{"id": "6523dbe2-c5db-54df-8ebd-e77c7997dcee", "input": "fn parse_low_raw(rawargs: impl IntoIterator < Item = impl Into < OsString > >) -> anyhow :: Result < LowArgs > {}", "output": "/// Parse the sequence of CLI arguments given a low level typed set of\n/// arguments.\n///\n/// This is exposed for testing that the correct low-level arguments are parsed\n/// from a CLI. It just runs the parser once over the CLI arguments. It doesn't\n/// setup logging or read from a config file.\n///\n/// This assumes the iterator given does *not* begin with the binary name.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/parse.rs", "source_line": 139, "tokens_input": 29, "tokens_output": 94, "quality_score": 0.9000001}
{"id": "9254b3bf-2e8a-53d9-b586-39789b18f2af", "input": "fn suggest(unrecognized: & str) -> Option < String > {}", "output": "/// Possibly return a message suggesting flags similar in the name to the one\n/// given.\n///\n/// The one given should be a flag given by the user (without the leading\n/// dashes) that was unrecognized. This attempts to find existing flags that\n/// are similar to the one given.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/parse.rs", "source_line": 404, "tokens_input": 14, "tokens_output": 70, "quality_score": 0.9000001}
{"id": "fe52e8fe-fb4c-5810-8dd5-9d6b1cbf7193", "input": "fn ngrams(flag_name: & str) -> BagOfWords < '_ > {}", "output": "/// Returns all 3-grams in the slice given.\n///\n/// If the slice doesn't contain a 3-gram, then one is artificially created by\n/// padding it out with a character that will never appear in a flag name.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/parse.rs", "source_line": 466, "tokens_input": 13, "tokens_output": 51, "quality_score": 0.9000001}
{"id": "97772e91-7c22-5431-8181-263bea1d2c9d", "input": "fn as_str(&self) -> & 'static str {}", "output": "/// Returns a string representation of this category.\n///\n/// This string is the name of the variable used in various templates for\n/// generated documentation. This name can be used for interpolation.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/mod.rs", "source_line": 222, "tokens_input": 9, "tokens_output": 51, "quality_score": 0.9000001}
{"id": "f8b7774d-8eee-5caf-a9f7-0756a41e853a", "input": "fn unwrap_switch(self) -> bool {}", "output": "/// Return the yes or no value of this switch.\n///\n/// If this flag value is not a switch, then this panics.\n///\n/// This is useful when writing the implementation of `Flag::update`.\n/// namely, callers usually know whether a switch or a value is expected.\n/// If a flag is something different, then it indicates a bug, and thus a\n/// panic is acceptable.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/mod.rs", "source_line": 277, "tokens_input": 9, "tokens_output": 89, "quality_score": 0.9000001}
{"id": "2d90b6f6-480b-539a-8e6d-500f90797939", "input": "fn get(&self) -> (usize , usize) {}", "output": "/// Returns the specific number of contextual lines that should be shown\n/// around each match. This takes proper precedent into account, i.e.,\n/// that `before` and `after` both partially override `both` in all cases.\n///\n/// By default, this returns `(0, 0)`.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/lowargs.rs", "source_line": 452, "tokens_input": 9, "tokens_output": 66, "quality_score": 0.9000001}
{"id": "de1e3385-4bd6-50db-925e-6770875efa40", "input": "enum PatternSource {}", "output": "/// Represents a source of patterns that ripgrep should search for.\n///\n/// The reason to unify these is so that we can retain the order of `-f/--flag`\n/// and `-e/--regexp` flags relative to one another.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/lowargs.rs", "source_line": 645, "tokens_input": 6, "tokens_output": 51, "quality_score": 0.9000001}
{"id": "0eb01759-cfe6-5f9d-b096-877efd78d162", "input": "fn parse<P>(path: P) -> anyhow :: Result < (Vec < OsString > , Vec < anyhow :: Error >) > {}", "output": "/// Parse a single ripgrep rc file from the given path.\n///\n/// On success, this returns a set of shell arguments, in order, that should\n/// be pre-pended to the arguments given to ripgrep at the command line.\n///\n/// If the file could not be read, then an error is returned. If there was\n/// a problem parsing one or more lines in the file, then errors are returned\n/// for each line in addition to successfully parsed arguments.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/config.rs", "source_line": 57, "tokens_input": 23, "tokens_output": 108, "quality_score": 0.9000001}
{"id": "0b5fe4ec-8ade-57b2-916e-d51896665eba", "input": "fn parse_reader<R>(rdr: R) -> anyhow :: Result < (Vec < OsString > , Vec < anyhow :: Error >) > {}", "output": "/// Parse a single ripgrep rc file from the given reader.\n///\n/// Callers should not provided a buffered reader, as this routine will use its\n/// own buffer internally.\n///\n/// On success, this returns a set of shell arguments, in order, that should\n/// be pre-pended to the arguments given to ripgrep at the command line.\n///\n/// If the reader could not be read, then an error is returned. If there was a\n/// problem parsing one or more lines, then errors are returned for each line\n/// in addition to successfully parsed arguments.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/config.rs", "source_line": 78, "tokens_input": 25, "tokens_output": 134, "quality_score": 0.9000001}
{"id": "1089db70-723e-5d45-8dd7-24309127be3d", "input": "fn render_custom_markup(mutdoc: & str, tag: & str, mutreplacement: impl FnMut (& str , & mut String)) -> String {}", "output": "/// Searches for `\\tag{...}` occurrences in `doc` and calls `replacement` for\n/// each such tag found.\n///\n/// The first argument given to `replacement` is the tag value, `...`. The\n/// second argument is the buffer that accumulates the full replacement text.\n///\n/// Since this function is only intended to be used on doc strings written into\n/// the program source code, callers should panic in `replacement` if there are\n/// any errors or unexpected circumstances.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/doc/mod.rs", "source_line": 18, "tokens_input": 29, "tokens_output": 117, "quality_score": 0.9000001}
{"id": "08ba9420-0aa8-5e53-b5c1-382a26e2fad7", "input": "fn runtime_cpu_features() -> Vec < String > {}", "output": "/// Returns the relevant SIMD features supported by the CPU at runtime.\n///\n/// This is kind of a dirty violation of abstraction, since it assumes\n/// knowledge about what specific SIMD features are being used by various\n/// components.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/doc/version.rs", "source_line": 83, "tokens_input": 12, "tokens_output": 59, "quality_score": 0.9000001}
{"id": "28701b7b-62e0-59b3-a2b7-c321793fbb4f", "input": "fn compile_cpu_features() -> Vec < String > {}", "output": "/// Returns the SIMD features supported while compiling ripgrep.\n///\n/// In essence, any features listed here are required to run ripgrep correctly.\n///\n/// This is kind of a dirty violation of abstraction, since it assumes\n/// knowledge about what specific SIMD features are being used by various\n/// components.\n///\n/// An easy way to enable everything available on your current CPU is to\n/// compile ripgrep with `RUSTFLAGS=\"-C target-cpu=native\"`. But note that\n/// the binary produced by this will not be portable.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/doc/version.rs", "source_line": 129, "tokens_input": 12, "tokens_output": 130, "quality_score": 0.9000001}
{"id": "c9950e7d-64fc-50b0-8df8-5ce67f23dcbf", "input": "fn format_short_columns(col1: & [String], col2: & [String], maxcol1: usize, _maxcol2: usize) -> String {}", "output": "/// Write two columns of documentation.\n///\n/// `maxcol1` should be the maximum length (in bytes) of the first column,\n/// while `maxcol2` should be the maximum length (in bytes) of the second\n/// column.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/doc/help.rs", "source_line": 87, "tokens_input": 27, "tokens_output": 51, "quality_score": 0.9000001}
{"id": "baeb34c2-a26a-51af-886c-ece547a5c659", "input": "fn remove_roff(v: & str) -> String {}", "output": "/// Removes roff syntax from `v` such that the result is approximately plain\n/// text readable.\n///\n/// This is basically a mish mash of heuristics based on the specific roff used\n/// in the docs for the flags in this tool. If new kinds of roff are used in\n/// the docs, then this may need to be updated to handle them.", "category": "function", "source_repo": "BurntSushi/ripgrep", "source_commit": "0a88ccc", "source_file": "crates/core/flags/doc/help.rs", "source_line": 216, "tokens_input": 10, "tokens_output": 80, "quality_score": 0.9000001}
{"id": "404dce50-4024-56da-af7d-d0fbcaee2312", "input": "fn cmd<F>(_next_line_help: bool, doc: F) -> Command {}", "output": "/// Build a clap application parameterized by usage strings.\n///\n/// The function given should take a clap argument name and return a help\n/// string. `cmd` will panic if a usage string is not defined.\n///\n/// This is an intentionally stand-alone module so that it can be used easily\n/// in a `build.rs` script to build shell completion files.", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_bench/benches/ripgrep.rs", "source_line": 288, "tokens_input": 14, "tokens_output": 86, "quality_score": 0.9000001}
{"id": "42bea20b-ab31-55ba-8cc6-7712eeba8a09", "input": "fn process_author_str(author: & str) -> String {}", "output": "/// replace all `:` with `, ` when not inside the `<>`\n///\n/// `\"author1:author2:author3\" => \"author1, author2, author3\"`\n/// `\"author1 <http://website1.com>:author2\" => \"author1 <http://website1.com>, author2\"`", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_derive/src/item.rs", "source_line": 1355, "tokens_input": 13, "tokens_output": 53, "quality_score": 0.9000001}
{"id": "a21f35e4-878e-5896-8e4b-d0b06b551678", "input": "fn parser(input: TokenStream) -> TokenStream {}", "output": "/// Generates the `Parser` implementation.\n///\n/// This is far less verbose than defining the `clap::Command` struct manually,\n/// receiving an instance of `clap::ArgMatches` from conducting parsing, and then\n/// implementing a conversion code to instantiate an instance of the user\n/// context struct.", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_derive/src/lib.rs", "source_line": 55, "tokens_input": 12, "tokens_output": 76, "quality_score": 0.9000001}
{"id": "14074246-f9a9-5d69-81e8-f49ab8f85389", "input": "fn find_subcommand_with_path<'cmd>(p: & 'cmd Command, path: Vec < & str >) -> & 'cmd Command {}", "output": "/// Finds the subcommand [`clap::Command`] from the given [`clap::Command`] with the given path.\n///\n/// <div class=\"warning\">\n///\n/// **NOTE:** `path` should not contain the root `bin_name`.\n///\n/// </div>", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/aot/generator/utils.rs", "source_line": 26, "tokens_input": 24, "tokens_output": 52, "quality_score": 0.9000001}
{"id": "7f001ec9-b388-577f-bb95-7895c2a1a37e", "input": "fn raw(kind: ErrorKind, message: impl Display) -> Self {}", "output": "/// Create an unformatted error\n///\n/// This is for you need to pass the error up to\n/// a place that has access to the `Command` at which point you can call [`Error::format`].\n///\n/// Prefer [`Command::error`] for generating errors.\n///\n/// [`Command::error`]: crate::Command::error", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/error/mod.rs", "source_line": 88, "tokens_input": 15, "tokens_output": 71, "quality_score": 0.9000001}
{"id": "9a61bca5-52aa-5ab4-8b71-65addeb6c25e", "input": "fn job(results: impl IntoIterator < Item = WorkerResult >, cmd: & CommandSet, config: & Config) -> ExitCode {}", "output": "/// An event loop that listens for inputs from the `rx` receiver. Each received input will\n/// generate a command with the supplied command template. The generated command will then\n/// be executed, and this process will continue until the receiver's sender has closed.", "category": "argument", "source_repo": "sharkdp/fd", "source_commit": "bf81fb9", "source_file": "src/exec/job.rs", "source_line": 11, "tokens_input": 28, "tokens_output": 68, "quality_score": 0.9000001}
{"id": "976d78f6-519e-55cd-a865-689462ff8f16", "input": "fn scan(paths: & [PathBuf], patterns: Vec < Regex >, config: Config) -> Result < ExitCode > {}", "output": "/// Recursively scan the given search path for files / pathnames matching the patterns.\n///\n/// If the `--exec` argument was supplied, this will create a thread pool for executing\n/// jobs in parallel from a given command line and the discovered paths. Otherwise, each\n/// path will simply be written to standard output.", "category": "argument", "source_repo": "sharkdp/fd", "source_commit": "bf81fb9", "source_file": "src/walk.rs", "source_line": 678, "tokens_input": 24, "tokens_output": 80, "quality_score": 0.9000001}
{"id": "ef30343f-5298-5b48-9a40-38c13c49f483", "input": "fn new_row(&mut self, params: TreeParams) -> & [TreePart] {}", "output": "/// Calculates the tree parts for an entry at the given depth and\n/// last-ness. The depth is used to determine where in the stack the tree\n/// part should be inserted, and the last-ness is used to determine which\n/// type of tree part to insert.\n///\n/// This takes a `&mut self` because the results of each file are stored\n/// and used in future rows.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/output/tree.rs", "source_line": 109, "tokens_input": 15, "tokens_output": 88, "quality_score": 0.9000001}
{"id": "7da24a14-943e-54af-878f-9a1816efebea", "input": "fn compare_files(self, a: & File < '_ >, b: & File < '_ >) -> Ordering {}", "output": "/// Compares two files to determine the order they should be listed in,\n/// depending on the search field.\n///\n/// The `natord` crate is used here to provide a more *natural* sorting\n/// order than just sorting character-by-character. This splits filenames\n/// into groups between letters and numbers, and then sorts those blocks\n/// together, so `file10` will sort after `file9`, instead of before it\n/// because of the `1`.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/fs/filter.rs", "source_line": 264, "tokens_input": 19, "tokens_output": 107, "quality_score": 0.9000001}
{"id": "43891b2a-d898-5263-a525-8c7f2c4eed21", "input": "fn search(&self, index: & Path, prefix_lookup: bool) -> f :: Git {}", "output": "/// Searches through this repository for a path (to a file or directory,\n/// depending on the prefix-lookup flag) and returns its Git status.\n///\n/// Actually querying the `git2` repository for the mapping of paths to\n/// Git statuses is only done once, and gets cached so we don\u2019t need to\n/// re-query the entire repository the times after that.\n///\n/// The temporary `Processing` enum variant is used after the `git2`\n/// repository is moved out, but before the results have been moved in!\n/// See <https://stackoverflow.com/q/45985827/3484614>", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/fs/feature/git.rs", "source_line": 152, "tokens_input": 17, "tokens_output": 137, "quality_score": 0.9000001}
{"id": "9f6a7eb9-9ec6-518d-b2e7-91842e3cae8d", "input": "fn repo_to_statuses(repo: & git2 :: Repository, workdir: & Path) -> Git {}", "output": "/// Iterates through a repository\u2019s statuses, consuming it and returning the\n/// mapping of files to their Git status.\n/// We will have already used the working directory at this point, so it gets\n/// passed in rather than deriving it from the `Repository` again.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/fs/feature/git.rs", "source_line": 227, "tokens_input": 19, "tokens_output": 67, "quality_score": 0.9000001}
{"id": "0c419369-9b09-5018-b2b6-6581e3431920", "input": "fn new(path: PathBuf) -> Self {}", "output": "/// Create a new, empty `Dir` object representing the directory at the given path.\n///\n/// This function does not attempt to read the contents of the directory; it merely\n/// initializes an instance of `Dir` with an empty `DirEntry` list and the specified path.\n/// To populate the `Dir` object with actual directory contents, use the `read` function.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/fs/dir.rs", "source_line": 39, "tokens_input": 8, "tokens_output": 88, "quality_score": 0.9000001}
{"id": "36e9c36e-e9f8-5a56-8741-e540fea7664c", "input": "fn deduce(matches: & MatchedFlags < '_ >) -> Result < Self , OptionsError > {}", "output": "/// Determines which sort field to use based on the `--sort` argument.\n/// This argument\u2019s value can be one of several flags, listed above.\n/// Returns the default sort field if none is given, or `Err` if the\n/// value doesn\u2019t correspond to a sort field we know about.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/filter.rs", "source_line": 55, "tokens_input": 20, "tokens_output": 68, "quality_score": 0.9000001}
{"id": "9b65488f-d853-5224-884a-c766debb822c", "input": "fn deduce(matches: & MatchedFlags < '_ >) -> Result < Self , OptionsError > {}", "output": "/// Determines the dot filter based on how many `--all` options were\n/// given: one will show dotfiles, but two will show `.` and `..` too.\n/// --almost-all is equivalent to --all, included for compatibility with\n/// `ls -A`.\n///\n/// It also checks for the `--tree` option, because of a special case\n/// where `--tree --all --all` won\u2019t work: listing the parent directory\n/// in tree mode would loop onto itself!\n///\n/// `--almost-all` binds stronger than multiple `--all` as we currently do not take the order\n/// of arguments into account and it is the safer option (does not clash with `--tree`)", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/filter.rs", "source_line": 150, "tokens_input": 20, "tokens_output": 150, "quality_score": 0.9000001}
{"id": "c77119a3-b6fa-5f69-8730-f7814b235e20", "input": "fn deduce(matches: & MatchedFlags < '_ >, can_tree: bool) -> Result < Self , OptionsError > {}", "output": "/// Determine which action to perform when trying to list a directory.\n/// There are three possible actions, and they overlap somewhat: the\n/// `--tree` flag is another form of recursion, so those two are allowed\n/// to both be present, but the `--list-dirs` flag is used separately.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/dir_action.rs", "source_line": 19, "tokens_input": 24, "tokens_output": 71, "quality_score": 0.9000001}
{"id": "1053364f-bcc1-5b07-9f2d-66d9fae61665", "input": "fn deduce(matches: & MatchedFlags < '_ >, tree: bool) -> Result < Self , OptionsError > {}", "output": "/// Determine which files should be recursed into, based on the `--level`\n/// flag\u2019s value, and whether the `--tree` flag was passed, which was\n/// determined earlier. The maximum level should be a number, and this\n/// will fail with an `Err` if it isn\u2019t.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/dir_action.rs", "source_line": 65, "tokens_input": 23, "tokens_output": 65, "quality_score": 0.9000001}
{"id": "6154a855-0750-548b-b637-43411ce683f9", "input": "fn deduce(matches: & MatchedFlags < '_ >) -> Result < Self , OptionsError > {}", "output": "/// Determine which file size to use in the file size column based on\n/// the user\u2019s options.\n///\n/// The default mode is to use the decimal prefixes, as they are the\n/// most commonly-understood, and don\u2019t involve trying to parse large\n/// strings of digits in your head. Changing the format to anything else\n/// involves the `--binary` or `--bytes` flags, and these conflict with\n/// each other.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/view.rs", "source_line": 325, "tokens_input": 20, "tokens_output": 101, "quality_score": 0.9000001}
{"id": "ebf3eda9-0de5-5238-975e-5bee99afb6c2", "input": "fn deduce(matches: & MatchedFlags < '_ >) -> Result < Self , OptionsError > {}", "output": "/// Determine which of a file\u2019s time fields should be displayed for it\n/// based on the user\u2019s options.\n///\n/// There are two separate ways to pick which fields to show: with a\n/// flag (such as `--modified`) or with a parameter (such as\n/// `--time=modified`). An error is signaled if both ways are used.\n///\n/// It\u2019s valid to show more than one column by passing in more than one\n/// option, but passing *no* options means that the user just wants to\n/// see the default set.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/options/view.rs", "source_line": 417, "tokens_input": 20, "tokens_output": 121, "quality_score": 0.9000001}
{"id": "b52c448a-b924-5fe6-964c-a9079c7d61df", "input": "fn parse_color_vars(&self, colours: & mut UiStyles) -> (ExtensionMappings , bool) {}", "output": "/// Parse the environment variables into `LS_COLORS` pairs, putting file glob\n/// colours into the `ExtensionMappings` that gets returned, and using the\n/// two-character UI codes to modify the mutable `Colours`.\n///\n/// Also returns if the `EZA_COLORS` variable should reset the existing file\n/// type mappings or not. The `reset` code needs to be the first one.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/theme/mod.rs", "source_line": 131, "tokens_input": 21, "tokens_output": 91, "quality_score": 0.9000001}
{"id": "aafdd6c4-5d68-57dd-8cc2-9ddbcd5b2b49", "input": "fn contract_repo_path(full_path: & Path, top_level_path: & Path) -> Option < String > {}", "output": "/// Contract the root component of a path based on the real path\n///\n/// Replaces the `top_level_path` in a given `full_path` with the provided\n/// `top_level_replacement` by walking ancestors and comparing its real path.", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/directory.rs", "source_line": 241, "tokens_input": 22, "tokens_output": 56, "quality_score": 0.9000001}
{"id": "18e03bbd-27cc-5639-8f6f-96b7e45070b8", "input": "fn module<'a>(context: & 'a Context) -> Option < Module < 'a > > {}", "output": "/// Creates a module showing if inside a nix-shell\n///\n/// The module will use the `$IN_NIX_SHELL` and `$name` environment variable to\n/// determine if it's inside a nix-shell and the name of it.\n///\n/// The following options are available:\n///     - `impure_msg` (string)  // change the impure msg\n///     - `pure_msg` (string)    // change the pure msg\n///     - `unknown_msg` (string) // change the unknown message\n///\n/// Will display the following:\n///     - pure (name)    // $name == \"name\" in a pure nix-shell\n///     - impure (name)  // $name == \"name\" in an impure nix-shell\n///     - pure           // $name == \"\" in a pure nix-shell\n///     - impure         // $name == \"\" in an impure nix-shell\n///     - unknown (name) // $name == \"name\" in an unknown nix-shell\n///     - unknown        // $name == \"\" in an unknown nix-shell", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/nix_shell.rs", "source_line": 60, "tokens_input": 17, "tokens_output": 210, "quality_score": 0.9000001}
{"id": "8c8e0413-b608-5290-89b5-025f6d6a78c2", "input": "fn module<'a>(context: & 'a Context) -> Option < Module < 'a > > {}", "output": "/// Creates a module with the Git branch in the current directory\n///\n/// Will display the branch name if the current directory is a git repo\n/// By default, the following symbols will be used to represent the repo's status:\n///   - `=` \u2013 This branch has merge conflicts\n///   - `\u21e1` \u2013 This branch is ahead of the branch being tracked\n///   - `\u21e3` \u2013 This branch is behind of the branch being tracked\n///   - `\u21d5` \u2013 This branch has diverged from the branch being tracked\n///   - `` \u2013 This branch is up-to-date with the branch being tracked\n///   - `?` \u2014 There are untracked files in the working directory\n///   - `$` \u2014 A stash exists for the local repository\n///   - `!` \u2014 There are file modifications in the working directory\n///   - `+` \u2014 A new file has been added to the staging area\n///   - `\u00bb` \u2014 A renamed file has been added to the staging area\n///   - `\u2718` \u2014 A file's deletion has been added to the staging area", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/git_status.rs", "source_line": 31, "tokens_input": 17, "tokens_output": 236, "quality_score": 0.9000001}
{"id": "ca2c2719-2ab3-5f57-a891-82d3f85f2738", "input": "fn module<'a>(context: & 'a Context) -> Option < Module < 'a > > {}", "output": "/// Creates a module with the currently active Docker context\n///\n/// Will display the Docker context if the following criteria are met:\n///     - There is a non-empty environment variable named `DOCKER_HOST`\n///     - Or there is a non-empty environment variable named `DOCKER_CONTEXT`\n///     - Or there is a file named `$HOME/.docker/config.json`\n///     - Or a file named `$DOCKER_CONFIG/config.json`\n///     - The file is JSON and contains a field named `currentContext`\n///     - The value of `currentContext` is not `default` or `desktop-linux`\n///     - If multiple criteria are met, we use the following order to define the docker context:\n///     - `DOCKER_HOST`, `DOCKER_CONTEXT`, $HOME/.docker/config.json, $`DOCKER_CONFIG/config.json`\n///     - (This is the same order docker follows, as `DOCKER_HOST` and `DOCKER_CONTEXT` override the\n///     config)", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/docker_context.rs", "source_line": 22, "tokens_input": 17, "tokens_output": 216, "quality_score": 0.9000001}
{"id": "d8e33e50-348a-525b-9318-87791821e756", "input": "fn module<'a>(name: Option < & str >, context: & 'a Context) -> Option < Module < 'a > > {}", "output": "/// Creates a module with the value of the chosen environment variable\n///\n/// Will display the environment variable's value if all of the following criteria are met:\n///     - `env_var.disabled` is absent or false\n///     - `env_var.variable` is defined\n///     - a variable named as the value of `env_var.variable` is defined", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/env_var.rs", "source_line": 14, "tokens_input": 23, "tokens_output": 82, "quality_score": 0.9000001}
{"id": "14a27429-7c03-573e-b1ee-8e97c33efb8d", "input": "fn is_write_allowed(folder_path: & Path) -> std :: result :: Result < bool , String > {}", "output": "/// Checks if the current user has write access right to the `folder_path`\n///\n/// First, the function extracts DACL from the given directory and then calls `AccessCheck` against\n/// the current process access token and directory's security descriptor.\n/// Does not work for network drives and always returns true", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/modules/utils/directory_win.rs", "source_line": 36, "tokens_input": 22, "tokens_output": 79, "quality_score": 0.9000001}
{"id": "2ab442cc-cf5d-5603-9793-fa2c7b416489", "input": "fn parse_style_string(style_string: & str, context: Option < & Context >) -> Option < Style > {}", "output": "/// Parse a style string which represents an ansi style. Valid tokens in the style\n string include the following:\n - 'fg:<color>'    (specifies that the color read should be a foreground color)\n - 'bg:<color>'    (specifies that the color read should be a background color)\n - 'underline'\n - 'bold'\n - 'italic'\n - 'inverted'\n - 'blink'\n - '`prev_fg`'        (specifies the color should be the previous foreground color)\n - '`prev_bg`'        (specifies the color should be the previous background color)\n - '<color>'       (see the `parse_color_string` doc for valid color strings)\n", "category": "argument", "source_repo": "starship/starship", "source_commit": "61eee25", "source_file": "src/config.rs", "source_line": 365, "tokens_input": 24, "tokens_output": 146, "quality_score": 0.9000001}
{"id": "f33fd8fe-3877-5c6a-b8d6-56b214737bf9", "input": "fn override_config(&mut self, mutconfig: Config) -> Config {}", "output": "/// Overrides the shared options (See `tokei::Config` for option\n/// descriptions) between the CLI and the config files. CLI flags have\n/// higher precedence than options present in config files.\n///\n/// #### Shared options\n/// * `hidden`\n/// * `no_ignore`\n/// * `no_ignore_parent`\n/// * `no_ignore_dot`\n/// * `no_ignore_vcs`\n/// * `types`", "category": "argument", "source_repo": "XAMPPRocky/tokei", "source_commit": "6c71dd7", "source_file": "src/cli.rs", "source_line": 399, "tokens_input": 16, "tokens_output": 85, "quality_score": 0.9000001}
{"id": "36f6af9b-8cd4-5ac3-a677-8c2f6a74227d", "input": "fn get_source_files(&self) -> Vec < PathBuf > {}", "output": "/// For this file, return a vector of alternate file paths that, if any of\n/// them exist, mean that *this* file should be coloured as \u201ccompiled\u201d.\n///\n/// The point of this is to highlight compiled files such as `foo.js` when\n/// their source file `foo.coffee` exists in the same directory.\n/// For example, `foo.js` is perfectly valid without `foo.coffee`, so we\n/// don\u2019t want to always blindly highlight `*.js` as compiled.\n/// (See also `FileType`)", "category": "example", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/info/sources.rs", "source_line": 20, "tokens_input": 12, "tokens_output": 115, "quality_score": 0.9000001}
{"id": "c5156053-1d0d-53c9-9bfd-daf6bdb24bf9", "input": "fn apply_overlay(mutbase: Style, overlay: Style) -> Style {}", "output": "/// Some of the styles are **overlays**: although they have the same attribute\n/// set as regular styles (foreground and background colours, bold, underline,\n/// etc), they\u2019re intended to be used to *amend* existing styles.\n///\n/// For example, the target path of a broken symlink is displayed in a red,\n/// underlined style by default. Paths can contain control characters, so\n/// these control characters need to be underlined too, otherwise it looks\n/// weird. So instead of having four separate configurable styles for \u201clink\n/// path\u201d, \u201cbroken link path\u201d, \u201ccontrol character\u201d and \u201cbroken control\n/// character\u201d, there are styles for \u201clink path\u201d, \u201ccontrol character\u201d, and\n/// \u201cbroken link overlay\u201d, the latter of which is just set to override the\n/// underline attribute on the other two.", "category": "example", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/theme/mod.rs", "source_line": 523, "tokens_input": 15, "tokens_output": 206, "quality_score": 0.9000001}
{"id": "0756bd0d-fb0c-5a11-b802-d0ecec8d7ed6", "input": "fn new() -> Self {}", "output": "/// Constructs a new empty Language with the comments provided.\n///\n/// ```\n/// # use tokei::*;\n/// let mut rust = Language::new();\n/// ```", "category": "example", "source_repo": "XAMPPRocky/tokei", "source_commit": "6c71dd7", "source_file": "src/language/mod.rs", "source_line": 37, "tokens_input": 5, "tokens_output": 35, "quality_score": 0.9000001}
{"id": "0c737ee2-5a9a-57fe-b73c-84c5bcd4612c", "input": "mod doc_comments {}", "output": "//! The preprocessing we apply to doc comments.\n//!\n//! #[derive(Parser)] works in terms of \"paragraphs\". Paragraph is a sequence of\n//! non-empty adjacent lines, delimited by sequences of blank (whitespace only) lines.", "category": "module", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_derive/src/utils/doc_comments.rs", "source_line": 1, "tokens_input": 5, "tokens_output": 55, "quality_score": 0.8500001}
{"id": "0d2756aa-f99b-5082-8951-897d657b131c", "input": "mod textwrap {}", "output": "//! Fork of `textwrap` crate\n//!\n//! Benefits of forking:\n//! - Pull in only what we need rather than relying on the compiler to remove what we don't need\n//! - `LineWrapper` is able to incrementally wrap which will help with `StyledStr`", "category": "module", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_builder/src/output/textwrap/mod.rs", "source_line": 1, "tokens_input": 4, "tokens_output": 60, "quality_score": 0.8500001}
{"id": "6a34d6c8-86f1-58d2-9f06-fd53b5822e0e", "input": "mod rust {}", "output": "//! 48 lines 36 code 6 comments 6 blanks\n//! ```rust\n//! fn main () {\n//!     // Comment\n//!\n//!     println!(\"Hello World!\");\n//! }\n//! ```", "category": "module", "source_repo": "XAMPPRocky/tokei", "source_commit": "6c71dd7", "source_file": "tests/data/rust.rs", "source_line": 1, "tokens_input": 3, "tokens_output": 35, "quality_score": 0.8500001}
{"id": "eb5fa199-8f18-5387-9558-1604e2af6663", "input": "fn complete(self) {}", "output": "/// Process the completion request and exit\n///\n/// **Warning:** `stdout` should not be written to before this has had a\n/// chance to run.", "category": "argument", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_complete/src/env/mod.rs", "source_line": 193, "tokens_input": 5, "tokens_output": 35, "quality_score": 0.8000001}
{"id": "d98c7581-c9fd-5b61-ab44-88bee9c651fc", "input": "fn iterate_over<I, T>(self, inner: I) -> Iter < I > {}", "output": "/// Creates an iterator that, as well as yielding each value, yields a\n/// `TreeParams` with the current depth and last flag filled in.", "category": "argument", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/output/tree.rs", "source_line": 165, "tokens_input": 14, "tokens_output": 34, "quality_score": 0.8000001}
{"id": "839ef27f-4c84-57dc-83c1-e5b09bfa451a", "input": "fn from_string(input: & str) -> Result < Self > {}", "output": "/// Parses an owner constraint\n/// Returns an error if the string is invalid\n/// Returns Ok(None) when string is acceptable but a noop (such as \"\" or \":\")", "category": "error", "source_repo": "sharkdp/fd", "source_commit": "bf81fb9", "source_file": "src/filter/owner.rs", "source_line": 27, "tokens_input": 13, "tokens_output": 39, "quality_score": 0.8000001}
{"id": "9eccadbc-85c0-5e88-8e22-de2bc59cc267", "input": "fn test_error_if_hidden_not_set_and_pattern_starts_with_dot() {}", "output": "/// Print error if search pattern starts with a dot and --hidden is not set\n/// (Unix only, hidden files on Windows work differently)", "category": "error", "source_repo": "sharkdp/fd", "source_commit": "bf81fb9", "source_file": "tests/tests.rs", "source_line": 2585, "tokens_input": 16, "tokens_output": 34, "quality_score": 0.8000001}
{"id": "fea0c321-c46c-5732-99d8-8b18742503f1", "input": "fn run() -> Result < bool > {}", "output": "/// Returns `Err(..)` upon fatal errors. Otherwise, returns `Ok(true)` on full success and\n/// `Ok(false)` if any intermediate errors occurred (were printed).", "category": "error", "source_repo": "sharkdp/bat", "source_commit": "cd06fe4", "source_file": "src/bin/bat/main.rs", "source_line": 345, "tokens_input": 8, "tokens_output": 40, "quality_score": 0.8000001}
{"id": "362d268b-7251-525a-8b31-854a2a8ce9e8", "input": "fn run(self) -> io :: Result < i32 > {}", "output": "/// # Errors\n///\n/// Will return `Err` if printing to stderr fails.", "category": "error", "source_repo": "eza-community/eza", "source_commit": "58b98cf", "source_file": "src/main.rs", "source_line": 255, "tokens_input": 10, "tokens_output": 17, "quality_score": 0.75000006}
{"id": "489abd5d-e391-524a-afa2-bcc87138c5d2", "input": "mod ripgrep {}", "output": "//! Used to simulate a fairly large number of options/flags and parsing with thousands of positional\n//! args\n//!\n//! CLI used is adapted from ripgrep 48a8a3a691220f9e5b2b08f4051abe8655ea7e8a", "category": "module", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_bench/benches/ripgrep.rs", "source_line": 1, "tokens_input": 4, "tokens_output": 48, "quality_score": 0.75000006}
{"id": "929c9e90-3d08-5cff-bd25-e31f2b8cbc04", "input": "mod rustup {}", "output": "//! Used to simulate a fairly large number of subcommands\n//!\n//! CLI used is from rustup 408ed84f0e50511ed44a405dd91365e5da588790", "category": "module", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "clap_bench/benches/rustup.rs", "source_line": 1, "tokens_input": 4, "tokens_output": 33, "quality_score": 0.75000006}
{"id": "02e0ec14-15b0-514f-9dd0-a538ca06ef60", "input": "mod escaped_positional {}", "output": "//! # Example (Builder API)\n//!\n//! ```rust\n//! ```\n//!", "category": "module", "source_repo": "clap-rs/clap", "source_commit": "b8be10b", "source_file": "src/_cookbook/escaped_positional.rs", "source_line": 1, "tokens_input": 7, "tokens_output": 14, "quality_score": 0.75000006}
{"id": "74de9077-ffe6-5a04-86b2-9a199b917b08", "input": "fn test_number_parsing_errors() {}", "output": "/// Make sure that fd fails if numeric arguments can not be parsed", "category": "error", "source_repo": "sharkdp/fd", "source_commit": "bf81fb9", "source_file": "tests/tests.rs", "source_line": 2538, "tokens_input": 9, "tokens_output": 17, "quality_score": 0.70000005}
